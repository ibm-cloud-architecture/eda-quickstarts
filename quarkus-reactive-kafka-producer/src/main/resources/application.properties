# Quarkus App Configuration
app.version=0.0.2
quarkus.log.console.format=%d{HH:mm:ss} %-5p [%c{2.}] (%t) %s%e%n
quarkus.log.console.level=DEBUG
quarkus.native.additional-build-args=-H:ResourceConfigurationFiles=.*\.json
quarkus.swagger-ui.always-include=true
#quarkus.http.cors=true
quarkus.http.port=8080

#################################
# Openshift Deployment setup
quarkus.openshift.route.expose=true
quarkus.openshift.env.configmaps=qs-order-mgr-cm
quarkus.openshift.labels.app=qs-order-rms
# Cluster CA for TLS Connection
# "es-demo-cluster-ca-cert" secret is automatically generated by the Kafka cluster named "es-demo"
quarkus.openshift.env.mapping.KAFKA_SSL_TRUSTSTORE_PASSWORD.from-secret=es-demo-cluster-ca-cert
quarkus.openshift.env.mapping.KAFKA_SSL_TRUSTSTORE_PASSWORD.with-key=ca.password
quarkus.openshift.mounts.kafka-cert.path=/deployments/certs/server
quarkus.openshift.secret-volumes.kafka-cert.secret-name=es-demo-cluster-ca-cert
# Kafka User for TLS Authentication
# "tls-user" secret is generated when we create a Kafka User with name "tls-user"
quarkus.openshift.env.mapping.KAFKA_SSL_KEYSTORE_PASSWORD.from-secret=eda-qs-tls-user
quarkus.openshift.env.mapping.KAFKA_SSL_KEYSTORE_PASSWORD.with-key=user.password
quarkus.openshift.mounts.user-cert.path=/deployments/certs/user
quarkus.openshift.secret-volumes.user-cert.secret-name=eda-qs-tls-user

# ----------------------------------------
# Small-Rye connector setup defining app connection to Kafka & Apicurio Registry
%prod.kafka.ssl.protocol=TLSv1.2
%prod.kafka.ssl.truststore.location=/deployments/certs/server/ca.p12
%prod.kafka.ssl.truststore.type=PKCS12

# REACTIVE messaging setup
mp.messaging.outgoing.orders.connector=smallrye-kafka
mp.messaging.outgoing.orders.topic=orders
%prod.mp.messaging.outgoing.orders.topic=${KAFKA_TOPIC_NAME}
mp.messaging.outgoing.orders.key.serializer=org.apache.kafka.common.serialization.StringSerializer
mp.messaging.outgoing.orders.value.serializer=io.apicurio.registry.serde.avro.AvroKafkaSerializer
# automatically register the schema with the registry, if not present
mp.messaging.outgoing.orders.apicurio.registry.auto-register=true

%prod.mp.messaging.outgoing.orders.apicurio.registry.url=${REGISTRY_URL}
%prod.mp.messaging.outgoing.orders.apicurio.avro.encoding=BINARY
%prod.mp.messaging.outgoing.orders.apicurio.registry.security.protocol=SSL
# if you need to use SASL instead of mutual TLS
# %prod.mp.messaging.outgoing.orders.apicurio.registry.sasl.jaas.config=${KAFKA_SASL_JAAS_CONFIG}
# %prod.mp.messaging.outgoing.orders.apicurio.registry.sasl.mechanism=SCRAM-SHA-512
%prod.mp.messaging.outgoing.orders.apicurio.registry.ssl.truststore.location=${KAFKA_SSL_TRUSTSTORE_LOCATION}
%prod.mp.messaging.outgoing.orders.apicurio.registry.ssl.truststore.password=${KAFKA_SSL_TRUSTSTORE_PASSWORD}
%prod.mp.messaging.outgoing.orders.apicurio.registry.ssl.keystore.location=${KAFKA_SSL_KEYSTORE_LOCATION}
%prod.mp.messaging.outgoing.orders.apicurio.registry.ssl.keystore.password=${KAFKA_SSL_KEYSTORE_PASSWORD}
%prod.mp.messaging.outgoing.orders.apicurio.registry.ssl.endpoint.identification.algorithm=${KAFKA_SSL_ENDPOINT_IDENTIFICATION_ALGORITHM}

%prod.mp.messaging.outgoing.orders.apicurio.registry.avro-datum-provider=io.apicurio.registry.serde.avro.ReflectAvroDatumProvider

%prod.mp.messaging.outgoing.orders.apicurio.root.schema.artifactId=OrderEvent

%prod.mp.messaging.outgoing.orders.apicurio.registry.artifact.group-id=OrderGroup
